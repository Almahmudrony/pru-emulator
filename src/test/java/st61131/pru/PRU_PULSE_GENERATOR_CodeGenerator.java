package st61131.pru;

/*Generated by MPS */

import com.github.vlsi.pru.plc110.ArithmeticInstruction;
import com.github.vlsi.pru.plc110.CodeEmitter;
import com.github.vlsi.pru.plc110.Format2Instruction;
import com.github.vlsi.pru.plc110.JumpInstruction;
import com.github.vlsi.pru.plc110.Label;
import com.github.vlsi.pru.plc110.LdiInstruction;
import com.github.vlsi.pru.plc110.MemoryTransferInstruction;
import com.github.vlsi.pru.plc110.QuickBranchInstruction;
import com.github.vlsi.pru.plc110.Register;
import com.github.vlsi.pru.plc110.RegisterField;

import java.util.function.Consumer;

public class PRU_PULSE_GENERATOR_CodeGenerator implements Consumer<CodeEmitter> {


  @Override
  public void accept(CodeEmitter ce) {
    Label startWhile0 = new Label("startWhile0");
    Label startWhileBody1 = new Label("startWhileBody1");
    Label if4 = new Label("if4");
    Label if6 = new Label("if6");
    Label elsIf7 = new Label("elsIf7");
    Label endIf5 = new Label("endIf5");
    Label ifTrue8 = new Label("ifTrue8");
    Label endIf9 = new Label("endIf9");
    Label endIf3 = new Label("endIf3");
    Label startRepeat10 = new Label("startRepeat10");
    Label endIf11 = new Label("endIf11");
    Label if13 = new Label("if13");
    Label endIf14 = new Label("endIf14");
    Label startWhile15 = new Label("startWhile15");
    Label startWhileBody16 = new Label("startWhileBody16");
    Label endWhile17 = new Label("endWhile17");
    Label endIf12 = new Label("endIf12");
    Label if19 = new Label("if19");
    Label endIf18 = new Label("endIf18");
    Label endWhile2 = new Label("endWhile2");
    // безопасные значения
    ce.visitInstruction(new LdiInstruction(new Register(2, RegisterField.b1), (short) 0).setComment(
        "enable => R2.b1"));
    ce.visitInstruction(
        new LdiInstruction(new Register(2, RegisterField.w2), (short) 100).setComment(
            "cycleLength => R2.w2"));
    ce.visitInstruction(new LdiInstruction(new Register(3, RegisterField.dw), (short) 0).setComment(
        "quantity => R3"));
    ce.visitLabel(startWhile0);
    ce.visitLabel(startWhileBody1);
    // собственно полезная работа
    // Call PRU_GENER_BURST
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(4, RegisterField.b0), new Register(2, RegisterField.b1), 0).setComment(
        "burst_enable => R4.b0, enable => R2.b1"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(5, RegisterField.dw), new Register(3, RegisterField.dw), 0).setComment(
        "burst_quantity => R5, quantity => R3"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, if4,
        new Register(4, RegisterField.b0), 0).setComment("burst_enable => R4.b0"));
    // Выключаемся
    ce.visitInstruction(new LdiInstruction(new Register(1, RegisterField.dw), (short) 0).setComment(
        "burst_qtyLeft => R1"));
    ce.visitInstruction(new LdiInstruction(new Register(2, RegisterField.b0), (short) 0).setComment(
        "burst_ready => R2.b0"));

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, endIf3,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(if4);
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.LT, if6,
        new Register(1, RegisterField.dw), 0).setComment("burst_qtyLeft => R1"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, elsIf7,
        new Register(2, RegisterField.b0), 0).setComment("burst_ready => R2.b0"));
    // Поступила команда на включение
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.LSL,
        new Register(1, RegisterField.dw), new Register(5, RegisterField.dw), 1).setComment(
        "burst_qtyLeft => R1, burst_quantity => R5"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(1, RegisterField.dw), new Register(1, RegisterField.dw), 1).setComment(
        "burst_qtyLeft => R1"));

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, endIf5,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(if6);
    // Идёт генерация
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(1, RegisterField.dw), new Register(1, RegisterField.dw), 1).setComment(
        "burst_qtyLeft => R1"));

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, endIf5,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(elsIf7);
    // Всё сгенерировали, ждём пока передёрнут enable для следующего включения

    ce.visitLabel(endIf5);

    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.EQ, ifTrue8,
        new Register(1, RegisterField.dw), 0).setComment("burst_qtyLeft => R1"));
    ce.visitInstruction(new LdiInstruction(new Register(2, RegisterField.b0), (short) 0).setComment(
        "burst_ready => R2.b0"));
    ce.visitInstruction(new QuickBranchInstruction(endIf9).setComment(""));
    ce.visitLabel(ifTrue8);
    ce.visitInstruction(new LdiInstruction(new Register(2, RegisterField.b0), (short) 1).setComment(
        "burst_ready => R2.b0"));
    ce.visitLabel(endIf9);


    ce.visitLabel(endIf3);

    // Если всё сделали, то out выключится. Если пачка ещё генерируется, то младший бит и есть меандр
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.AND,
        new Register(4, RegisterField.b0), new Register(1, RegisterField.dw), 1).setComment(
        "burst_out => R4.b0, burst_qtyLeft => R1"));
    //
    // End PRU_GENER_BURST
    ce.visitInstruction(
        new LdiInstruction(new Register(5, RegisterField.dw), (short) 28684).setComment(
            "controlRegisterAddress => R5"));
    //
    ce.visitLabel(startRepeat10);
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(4, RegisterField.b1)).setAddress(3).setOffset(0).setLength(
        1).encode().setComment("dataReady => R4.b1"));
    //
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.EQ, endIf11,
        new Register(4, RegisterField.b1), 0).setComment("dataReady => R4.b1"));
    // Загружаем параметры
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(3, RegisterField.dw)).setAddress(3).setOffset(100).setLength(
        4).encode().setComment("quantity => R3"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(2, RegisterField.w2)).setAddress(3).setOffset(104).setLength(
        2).encode().setComment("cycleLength => R2.w2"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(2, RegisterField.b1)).setAddress(3).setOffset(108).setLength(
        1).encode().setComment("enable => R2.b1"));

    //
    // Выводим выгружаем состояние в ПЛК
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.STORE,
        new Register(2, RegisterField.b0)).setAddress(3).setOffset(112).setLength(
        1).encode().setComment("burst_ready => R2.b0"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(6, RegisterField.dw), new Register(1, RegisterField.dw), 0).setComment(
        "qtyLeft => R6, burst_qtyLeft => R1"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.STORE,
        new Register(6, RegisterField.dw)).setAddress(3).setOffset(116).setLength(
        4).encode().setComment("qtyLeft => R6"));
    ce.visitInstruction(new LdiInstruction(new Register(4, RegisterField.b1), (short) 0).setComment(
        "dataReady => R4.b1"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.STORE,
        new Register(4, RegisterField.b1)).setAddress(3).setOffset(0).setLength(
        1).encode().setComment("dataReady => R4.b1"));

    ce.visitLabel(endIf11);

    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(4, RegisterField.w1)).setAddress(new Register(5, RegisterField.dw)).setOffset(
        0).setLength(2).encode().setComment(
        "currentCycles => R4.w1, controlRegisterAddress => R5"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(4, RegisterField.w1), new Register(4, RegisterField.w1), 40).setComment(
        "currentCycles => R4.w1"));

    ce.visitInstruction(
        new QuickBranchInstruction(QuickBranchInstruction.Operation.GT, startRepeat10,
            new Register(4, RegisterField.w1), new Register(2, RegisterField.w2)).setComment(
            "currentCycles => R4.w1, cycleLength => R2.w2"));

    //
    // Call WAIT_TICK
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(4, RegisterField.w1), new Register(2, RegisterField.w2), 0).setComment(
        "tmpWAIT_TICK_0_pruCycleLength => R4.w1, cycleLength => R2.w2"));
    // 0x00007000..0x00007FFF -- PRU0 Control Registers, 0xC -- cycle count register
    ce.visitInstruction(
        new LdiInstruction(new Register(5, RegisterField.dw), (short) 28684).setComment(
            "tmpWAIT_TICK_0_controlRegisterAddress => R5"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(6, RegisterField.w0)).setAddress(new Register(5, RegisterField.dw)).setOffset(
        0).setLength(2).encode().setComment(
        "Load cycle count, 1+wdcnt*1==2 cycles, tmpWAIT_TICK_0_currentCycles => R6.w0, tmpWAIT_TICK_0_controlRegisterAddress => R5"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(6, RegisterField.w0), new Register(6, RegisterField.w0), 8).setComment(
        "tmpWAIT_TICK_0_currentCycles => R6.w0"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.LT, if13,
        new Register(4, RegisterField.w1), new Register(6, RegisterField.w0)).setComment(
        "tmpWAIT_TICK_0_pruCycleLength => R4.w1, tmpWAIT_TICK_0_currentCycles => R6.w0"));
    ce.visitInstruction(new LdiInstruction(new Register(6, RegisterField.w2), (short) 0).setComment(
        "tmpWAIT_TICK_0_cyclesLeft => R6.w2"));

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, endIf12,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(if13);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(6, RegisterField.w2), new Register(4, RegisterField.w1),
        new Register(6, RegisterField.w0)).setComment(
        "tmpWAIT_TICK_0_cyclesLeft => R6.w2, tmpWAIT_TICK_0_pruCycleLength => R4.w1, tmpWAIT_TICK_0_currentCycles => R6.w0"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.XOR,
        new Register(6, RegisterField.w2), new Register(6, RegisterField.w2), 0).setComment(
        "tmpWAIT_TICK_0_cyclesLeft => R6.w2"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.BC, endIf14,
        new Register(6, RegisterField.w2), 0).setComment("tmpWAIT_TICK_0_cyclesLeft => R6.w2"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.XOR,
        new Register(6, RegisterField.w2), new Register(6, RegisterField.w2), 1).setComment(
        "tmpWAIT_TICK_0_cyclesLeft => R6.w2"));
    ce.visitLabel(endIf14);

    ce.visitLabel(startWhile15);
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.EQ, endWhile17,
        new Register(6, RegisterField.w2), 0).setComment("tmpWAIT_TICK_0_cyclesLeft => R6.w2"));
    ce.visitLabel(startWhileBody16);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(6, RegisterField.w2), new Register(6, RegisterField.w2), 2).setComment(
        "tmpWAIT_TICK_0_cyclesLeft => R6.w2"));

    ce.visitInstruction(
        new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, startWhileBody16,
            new Register(6, RegisterField.w2), 0).setComment("tmpWAIT_TICK_0_cyclesLeft => R6.w2"));
    ce.visitLabel(endWhile17);


    ce.visitLabel(endIf12);

    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.STORE,
        new Register(6, RegisterField.w2)).setAddress(new Register(5, RegisterField.dw)).setOffset(
        0).setLength(2).encode().setComment(
        "Load cycle count, 1+wdcnt*1==2 cycles, tmpWAIT_TICK_0_cyclesLeft => R6.w2, tmpWAIT_TICK_0_controlRegisterAddress => R5"));
    //
    // End WAIT_TICK
    //
    // Call PRU_OUT1
    // Ага, ассемблерные вставки
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, if19,
        new Register(4, RegisterField.b0), 0).setComment("tmpPRU_OUT1_0_Q => R4.b0"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.CLR,
        new Register(30, RegisterField.dw), new Register(30, RegisterField.dw), 28).setComment(""));

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, endIf18,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(if19);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SET,
        new Register(30, RegisterField.dw), new Register(30, RegisterField.dw), 28).setComment(""));

    ce.visitLabel(endIf18);

    // End PRU_OUT1

    ce.visitInstruction(new JumpInstruction(Format2Instruction.Operation.JMP, startWhileBody1,
        new Register(1, RegisterField.dw)).setComment(""));
    ce.visitLabel(endWhile2);


  }
}
