package st61131.pru;

/*Generated by MPS */

import com.github.vlsi.pru.plc110.ArithmeticInstruction;
import com.github.vlsi.pru.plc110.CodeEmitter;
import com.github.vlsi.pru.plc110.Label;
import com.github.vlsi.pru.plc110.LdiInstruction;
import com.github.vlsi.pru.plc110.MemoryTransferInstruction;
import com.github.vlsi.pru.plc110.QuickBranchInstruction;
import com.github.vlsi.pru.plc110.Register;
import com.github.vlsi.pru.plc110.RegisterField;

import java.util.function.Consumer;

public class PRU_BLINK1_CodeGenerator implements Consumer<CodeEmitter> {
  @Override
  public void accept(CodeEmitter ce) {
    Label startWhileBody0 = new Label("startWhileBody0");
    Label if3 = new Label("if3");
    Label endIf4 = new Label("endIf4");
    Label startWhileBody5 = new Label("startWhileBody5");
    Label endWhile6 = new Label("endWhile6");
    Label endIf2 = new Label("endIf2");
    Label if8 = new Label("if8");
    Label endIf7 = new Label("endIf7");
    Label endWhile1 = new Label("endWhile1");
    ce.visitLabel(startWhileBody0);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.XOR,
        new Register(1, RegisterField.b0), new Register(1, RegisterField.b0), 1).setComment(
        "out => R1.b0"));
    // Call WAIT_TICK
    ce.visitInstruction(
        new LdiInstruction(new Register(1, RegisterField.w1), (short) 30000).setComment(
            "tmpWAIT_TICK_2_pruCycleLength => R1.w1"));
    // 0x00007000..0x00007FFF -- PRU0 Control Registers, 0xC -- cycle count register
    ce.visitInstruction(
        new LdiInstruction(new Register(2, RegisterField.dw), (short) 28684).setComment(
            "tmpWAIT_TICK_2_controlRegisterAddress => R2"));
    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.LOAD,
        new Register(3, RegisterField.w0)).setAddress(new Register(2, RegisterField.dw)).setOffset(
        0).setLength(2).encode().setComment(
        "Load cycle count, 1+wdcnt*1==2 cycles, tmpWAIT_TICK_2_currentCycles => R3.w0, tmpWAIT_TICK_2_controlRegisterAddress => R2"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(3, RegisterField.w0), new Register(3, RegisterField.w0), 8).setComment(
        "tmpWAIT_TICK_2_currentCycles => R3.w0"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.LT, if3,
        new Register(1, RegisterField.w1), new Register(3, RegisterField.w0)).setComment(
        "tmpWAIT_TICK_2_pruCycleLength => R1.w1, tmpWAIT_TICK_2_currentCycles => R3.w0"));
    ce.visitInstruction(new LdiInstruction(new Register(3, RegisterField.w2), (short) 0).setComment(
        "tmpWAIT_TICK_2_cyclesLeft => R3.w2"));

    ce.visitInstruction(new QuickBranchInstruction(endIf2).setComment(""));
    ce.visitLabel(if3);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(3, RegisterField.w2), new Register(1, RegisterField.w1),
        new Register(3, RegisterField.w0)).setComment(
        "tmpWAIT_TICK_2_cyclesLeft => R3.w2, tmpWAIT_TICK_2_pruCycleLength => R1.w1, tmpWAIT_TICK_2_currentCycles => R3.w0"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.XOR,
        new Register(3, RegisterField.w2), new Register(3, RegisterField.w2), 0).setComment(
        "tmpWAIT_TICK_2_cyclesLeft => R3.w2"));
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.BC, endIf4,
        new Register(3, RegisterField.w2), 0).setComment("tmpWAIT_TICK_2_cyclesLeft => R3.w2"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.XOR,
        new Register(3, RegisterField.w2), new Register(3, RegisterField.w2), 1).setComment(
        "tmpWAIT_TICK_2_cyclesLeft => R3.w2"));
    ce.visitLabel(endIf4);

    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.EQ, endWhile6,
        new Register(3, RegisterField.w2), 0).setComment("tmpWAIT_TICK_2_cyclesLeft => R3.w2"));
    ce.visitLabel(startWhileBody5);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SUB,
        new Register(3, RegisterField.w2), new Register(3, RegisterField.w2), 2).setComment(
        "tmpWAIT_TICK_2_cyclesLeft => R3.w2"));

    ce.visitInstruction(
        new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, startWhileBody5,
            new Register(3, RegisterField.w2), 0).setComment("tmpWAIT_TICK_2_cyclesLeft => R3.w2"));
    ce.visitLabel(endWhile6);


    ce.visitLabel(endIf2);

    ce.visitInstruction(new MemoryTransferInstruction(MemoryTransferInstruction.Operation.STORE,
        new Register(3, RegisterField.w2)).setAddress(new Register(2, RegisterField.dw)).setOffset(
        0).setLength(2).encode().setComment(
        "Load cycle count, 1+wdcnt*1==2 cycles, tmpWAIT_TICK_2_cyclesLeft => R3.w2, tmpWAIT_TICK_2_controlRegisterAddress => R2"));
    //
    // End WAIT_TICK
    // Call PRU_OUT1
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.ADD,
        new Register(1, RegisterField.b1), new Register(1, RegisterField.b0), 0).setComment(
        "tmpPRU_OUT1_3_Q => R1.b1, out => R1.b0"));
    // Ага, ассемблерные вставки
    ce.visitInstruction(new QuickBranchInstruction(QuickBranchInstruction.Operation.NE, if8,
        new Register(1, RegisterField.b1), 0).setComment("tmpPRU_OUT1_3_Q => R1.b1"));
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.CLR,
        new Register(30, RegisterField.dw), new Register(30, RegisterField.dw), 28).setComment(""));

    ce.visitInstruction(new QuickBranchInstruction(endIf7).setComment(""));
    ce.visitLabel(if8);
    ce.visitInstruction(new ArithmeticInstruction(ArithmeticInstruction.Operation.SET,
        new Register(30, RegisterField.dw), new Register(30, RegisterField.dw), 28).setComment(""));

    ce.visitLabel(endIf7);

    // End PRU_OUT1

    ce.visitInstruction(new QuickBranchInstruction(startWhileBody0).setComment(""));
    ce.visitLabel(endWhile1);


  }
}
